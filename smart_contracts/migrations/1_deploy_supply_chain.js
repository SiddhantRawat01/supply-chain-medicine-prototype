// migrations/2_deploy_contracts.js
const SupplyChainLogic = artifacts.require("SupplyChainLogic");
const SupplyChainProxy = artifacts.require("SupplyChainProxy");
// AccessControlWithOwner ABI is not needed here as we interact via Logic/Proxy ABIs
// const AccessControlWithOwner = artifacts.require("AccessControlWithOwner");

// List of role name strings used in the contract's keccak256 hashing
// CRITICAL: These MUST exactly match the strings used in AccessControlWithOwner.sol
const ROLE_NAMES = [
  "ADMIN_ROLE",
  "SUPPLIER_ROLE",
  "TRANSPORTER_ROLE",
  "MANUFACTURER_ROLE",
  "WHOLESALER_ROLE",
  "DISTRIBUTOR_ROLE",
  "CUSTOMER_ROLE"
];

module.exports = async function (deployer, network, accounts) {
  // Use the first account from the provider (e.g., accounts[0] from MetaMask/HDWallet)
  const deployerAccount = accounts[0];

  console.log(`\n🚀 Deploying contracts using account: ${deployerAccount} on network: ${network}`);
  console.log(`   Deployer Balance: ${web3.utils.fromWei(await web3.eth.getBalance(deployerAccount), 'ether')} ETH`);

  // --- Step 1: Deploy the Logic Contract ---
  console.log("\n📡 Deploying SupplyChainLogic Implementation...");
  await deployer.deploy(SupplyChainLogic);
  const logicContractInstance = await SupplyChainLogic.deployed(); // Get instance of deployed logic contract
  console.log(`✅ SupplyChainLogic Implementation deployed at: ${logicContractInstance.address}`);
  
  // --> ADD THIS CHECK <--
  const logicCode = await web3.eth.getCode(logicContractInstance.address);
  if (!logicCode || logicCode === '0x' || logicCode === '0x0') {
      console.error(`❌ FATAL ERROR: No contract code found at deployed Logic address ${logicContractInstance.address}!`);
      throw new Error("SupplyChainLogic deployment verification failed.");
  }
console.log(`   Code found at logic address. Proceeding to deploy Proxy...`);
  // --- Step 2: Deploy the Proxy Contract ---
  console.log(`\n🔗 Deploying SupplyChainProxy, linking to Logic at ${logicContractInstance.address}...`);
  // Pass the logic contract's address to the proxy constructor.
  // The constructor handles the critical delegatecall to `initialize(deployerAccount)`.
  await deployer.deploy(SupplyChainProxy, logicContractInstance.address);
  const proxyContractInstance = await SupplyChainProxy.deployed(); // Get instance of deployed proxy contract
  console.log(`✅ SupplyChainProxy deployed at: ${proxyContractInstance.address}`);

  // --- Step 3: Post-Deployment Verification ---
  // Interact with the system *through the Proxy address* using the Logic contract's ABI.
  // This ensures we are checking the state stored within the proxy context.
  console.log(`\n🔎 Interacting via Proxy Address (${proxyContractInstance.address}) using Logic ABI...`);
  const logicViaProxy = await SupplyChainLogic.at(proxyContractInstance.address);

  // --- Step 3a: Verify Owner Initialization ---
  console.log(`\n🔍 Verifying Owner State in Proxy...`);
  let ownerFromStorage;
  try {
      // Call the public 'owner()' function generated by the 'public owner' variable
      // in AccessControlWithOwner (accessible via logicViaProxy due to inheritance).
      // This reads storage slot 0 FROM THE PROXY's storage.
      ownerFromStorage = await logicViaProxy.owner();
  } catch (error) {
       console.error(`   ❌ Error calling owner() view function: ${error.message}`);
       throw new Error("Verification failed: Could not read owner state from proxy.");
  }

  if (ownerFromStorage.toLowerCase() === deployerAccount.toLowerCase()) {
    console.log(`👍 Owner correctly initialized in Proxy storage: ${ownerFromStorage}`);
  } else {
    // This indicates the `owner = deployer` assignment failed during the initialize delegatecall.
    console.error(`❌ FATAL ERROR: Owner verification failed!`);
    console.error(`   Expected Owner: ${deployerAccount}`);
    console.error(`   Owner read from Proxy Storage: ${ownerFromStorage}`);
  }

  // --- Step 3b: Calculate Role Hashes Locally ---
  // We MUST calculate the hashes in the script to match the contract.
  // We CANNOT fetch `bytes32 constant` values directly from the deployed contract.
  console.log(`\n🔍 Calculating Role Hashes locally using web3.utils.keccak256...`);
  const roleHashes = {};
  let adminRoleHash = null; // Variable to specifically hold the ADMIN_ROLE hash

  for (const roleName of ROLE_NAMES) {
      try {
          // Use web3.utils.keccak256 (provided by Truffle's environment)
          const calculatedHash = web3.utils.keccak256(roleName);
          roleHashes[roleName] = calculatedHash;
          console.log(`   ${roleName.padEnd(20)}: ${calculatedHash}`);
          if (roleName === "ADMIN_ROLE") {
              adminRoleHash = calculatedHash;
          }
      } catch (error) {
           // This shouldn't fail unless web3 is unavailable, but good practice check
           console.error(`   ❌ FATAL ERROR: Failed to calculate hash for ${roleName}: ${error.message}`);
      }
  }

  // --- Step 3c: Verify ADMIN_ROLE Grant for Deployer ---
  // This is the MOST CRITICAL verification step related to the original issue.
  console.log(`\n🔍 Verifying Deployer's implicit ADMIN_ROLE (${deployerAccount})...`);
  let deployerHasAdminRole = false;
  try {
      // Call 'hasRole(ADMIN_ROLE, deployerAccount)' via the proxy.
      // V5 logic: This checks if deployerAccount == owner in proxy storage.
      deployerHasAdminRole = await logicViaProxy.hasRole(adminRoleHash, deployerAccount);
  } catch(error) {
      console.error(`   ❌ Error calling hasRole view function: ${error.message}`);
  }

  // Check the boolean result from hasRole
  if (deployerHasAdminRole) {
    console.log(`👍 Deployer/Owner correctly has implicit ADMIN_ROLE status.`); // Changed log
  } else {
    console.error(`❌ FATAL ERROR: Implicit ADMIN_ROLE Verification Failed!`); // Changed log
    console.error(`   Deployer/Owner (${deployerAccount}) DOES NOT have ADMIN_ROLE (${adminRoleHash}) according to Proxy state (owner check failed).`); // Changed log
    console.error(`   This strongly indicates a failure during the 'owner = deployer' assignment within the 'initialize' delegatecall, or the hasRole logic.`); // Changed log
    // Removed references to _setupRole for ADMIN_ROLE
  }

  // --- Deployment Summary ---
  console.log("\n\n====== DEPLOYMENT COMPLETE & VERIFIED ======");
  console.log(`Implementation Contract (SupplyChainLogic): ${logicContractInstance.address}`);
  console.log(`Proxy Contract (SupplyChainProxy):        ${proxyContractInstance.address}`);
  console.log(`Initial Owner / Admin (Deployer):       ${deployerAccount}`);
  console.log("\n--- Role Hashes (Calculated) ---");
  // Display calculated hashes for reference
  for (const roleName in roleHashes) {
      console.log(`   ${roleName.padEnd(20)}: ${roleHashes[roleName]}`);
  }
  console.log("\n👉 IMPORTANT: Use the PROXY address in your frontend application:");
  console.log(`   ${proxyContractInstance.address}`);
  console.log("=========================================\n");

  // --- Optional Post-Deployment Role Setup Example ---
  /*
  const supplierAccount = "0xReplaceWithSupplierAddress"; // Replace with actual supplier address
  const supplierRoleHash = roleHashes["SUPPLIER_ROLE"]; // Use calculated hash

  // Example: Grant SUPPLIER_ROLE only on Sepolia and if address/hash are valid
  if (network === 'sepolia' && supplierAccount && supplierAccount.startsWith("0x") && supplierRoleHash) {
    try {
      console.log(`\n🔧 Granting SUPPLIER_ROLE (${supplierRoleHash}) to ${supplierAccount}...`);
      // Use the proxy instance (logicViaProxy) and the deployer account (which has ADMIN_ROLE)
      const tx = await logicViaProxy.grantRole(supplierRoleHash, supplierAccount, { from: deployerAccount });
      console.log(`   ✅ Granted SUPPLIER_ROLE. Tx Hash: ${tx.tx}`);

      // Optional: Verify grant immediately after
      const hasSupplierRole = await logicViaProxy.hasRole(supplierRoleHash, supplierAccount);
      console.log(`   Verification: Account ${supplierAccount} has SUPPLIER_ROLE: ${hasSupplierRole}`);
      if (!hasSupplierRole) {
          console.warn(`   🟡 Warning: Grant successful but immediate verification failed. Check transaction/state.`);
      }

    } catch (error) {
      // Catch errors during the grantRole transaction
      console.error(`   ❌ Failed to grant SUPPLIER_ROLE to ${supplierAccount}: ${error.message}`);
      // Consider logging the error details or revert reason if available
      // if (error.reason) console.error(`      Reason: ${error.reason}`);
    }
  } else if (network === 'sepolia') {
      console.log(`\n🟡 Skipping optional SUPPLIER_ROLE grant (Invalid address or hash).`);
  }
  // Add more role grants as needed...
  */
};